from __future__ import annotations
from typing import Type, Dict, Callable, Any, TYPE_CHECKING, Literal
from abc import ABC, abstractmethod
from logging import Logger, getLogger
from collections import deque

from blueshift.lib.trades._order_types import ProductType
from blueshift.lib.trades._accounts import BlotterAccount
from blueshift.lib.trades._order import Order
from blueshift.lib.trades._position import Position
from ..assets._assets import Asset, MarketData
from blueshift.lib.common.enums import AlgoMessageType, BlotterType
from blueshift.lib.common.constants import Currency
from blueshift.lib.common.functions import create_message_envelope
from blueshift.lib.exceptions import InitializationError, get_clean_err_msg

from ..streaming import StreamingPublisher
from ..nostreaming import NoPublisher
from ..assets.assets import IAssetFinder
from ..data.data_portal import DataPortal
from ..plugin_manager import load_plugins
from .broker import IBroker
from ._tracker import Tracker

if TYPE_CHECKING:
    import pandas as pd
else:
    import blueshift.lib.common.lazy_pandas as pd

def serialize_asset_symbol(asset:Asset)->str:
    sym = asset.exchange_ticker
    
    try:
        product = ProductType(asset.get_product_type())
        if product == ProductType.DELIVERY:
            return sym
        return sym + f'[{product.name}]'
    except Exception:
        return sym


class IBlotter(ABC):
    """
        Blotter tracks the orders generated by the algo and matches them
        from the order status received from the broker API. It also computes
        the positions that should arise out of those algo orders and matches
        against the positions from broker API. Cumulative sum of the realized
        and unrealized pnls from these positions are algo pnl. This helps us
        avoid computing algo performance solely based on account information,
        as the account can also be affected by other means (manual trades or
        capital withdrawals etc.).

        This is not designed to be implemented by users. However, in case it is done, ensure the 
        actual implementation must implement the following, apart from the abstract methods.
            _save: save this blotter (excludes children)
            _read: read this blotter from previously saved data (excludes children)
            _roll: roll this blotter end-of-day (excludes children)
            _finalize: finalize this blotter (excludes children)
            _update_valuation: update valuation of current positions of this blotter (excludes children)
            _orders_no_reconcile: returns the orders dict without running any reconciliation
            _on_error: algo error handler for this blotter (excludes children)
            _on_cancel: algo cancel handler for this blotter (excludes children)

        These are corresponding methods without the leading underscore that is specific to only this 
        instance of the blotter, and not its children.

        Args:
            ``name (str)``: Unique name of the run.

            ``asset_finder (object)``: Asset finder object for the run.

            ``data_portal (object)``: Data portal object for the run.

            ``broker (object)``: Broker object for the run.

            ``logger (object)``: Logger object of the run.

            ``account_net (float)``: Net value of the account.

            ``timestamp (Timestamp)``: Timestamp at creation.

            ``env (object)``: TradingEnvronent object for the run.

            ``ccy (object)``: Blotter currency.
    """
    _FREQ = 60000000000
    
    def __init__(self, name:str, *args, **kwargs):
        self._name = name
        self._topic = kwargs.get('topic', self._name)
        self._blotter_type = BlotterType.VIRTUAL
        self._logger = kwargs.get('logger', getLogger(name))
        self._blotters = {}
        self.parent = None
        self._context_name = self.name
        self._needs_reconciliation = False # set by the algo on handle_event
        self._publisher = kwargs.get('publisher', NoPublisher())
        self._quick_mode = False

        if not isinstance(self._logger, Logger):
            raise InitializationError(f'expected a logger object, got {type(self._logger)}')
        
        if not isinstance(self._publisher, StreamingPublisher):
            raise InitializationError(f'expected a streaming publisher, got {type(self._publisher)}')
    
    @property
    def name(self) -> str:
        return self._name
    
    @property
    def topic(self) -> str:
        return self._topic
    
    @topic.setter
    def topic(self, value):
        self._topic = str(value)
    
    @property
    def blotter_type(self) -> BlotterType:
        return self._blotter_type
    
    @blotter_type.setter
    def blotter_type(self, value):
        self._blotter_type = value
        
    @property
    def logger(self) -> Logger:
        return self._logger
    
    @logger.setter
    def logger(self, value):
        self._logger = value
        
    @property
    def publisher(self) ->StreamingPublisher:
        return self._publisher
    
    @publisher.setter
    def publisher(self, value):
        self._publisher = value
    
    @property
    def blotters(self) -> dict[str, IBlotter]:
        return self._blotters
    
    @property
    def needs_reconciliation(self) -> bool:
        return self._needs_reconciliation
    
    @needs_reconciliation.setter
    def needs_reconciliation(self, value):
        self._needs_reconciliation = value
        for name in self.blotters:
            self.blotters[name].needs_reconciliation = value

    @property
    @abstractmethod
    def ccy(self) -> Currency:
        raise NotImplementedError
        
    @property
    @abstractmethod
    def asset_finder(self) -> IAssetFinder:
        raise NotImplementedError
        
    @property
    @abstractmethod
    def data_portal(self) -> DataPortal:
        raise NotImplementedError
        
    @property
    @abstractmethod
    def broker(self) -> IBroker:
        raise NotImplementedError

    @property
    @abstractmethod
    def timestamp(self) -> pd.Timestamp|None:
        raise NotImplementedError
    
    @timestamp.setter
    def timestamp(self, timestamp:pd.Timestamp):
        raise NotImplementedError

    @property
    @abstractmethod
    def account(self) -> BlotterAccount:
        raise NotImplementedError

    @property
    @abstractmethod
    def orders(self) -> dict[str,Order]:
        raise NotImplementedError
        
    def _orders_no_reconcile(self) -> dict[str,Order]:
        raise NotImplementedError

    @property
    @abstractmethod
    def open_orders(self) -> dict[str,Order]:
        raise NotImplementedError

    @property
    @abstractmethod
    def portfolio(self) -> dict[Asset,Position]:
        """ current positions (a copy of current position, after reconcile). """
        raise NotImplementedError

    @property
    @abstractmethod
    def positions(self) -> dict[pd.Timestamp,dict[str,dict]]:
        """ 
            historical positions -> keyed by todays date. The inner dict returns the 
            positions for that day keyed by the asset symbol and a dict representation
            of the position details.
        """
        raise NotImplementedError
        
    @property
    @abstractmethod
    def round_trips(self) -> list|deque:
        """ a list of positions that has be fully closed, in dict representation. """
        raise NotImplementedError

    @property
    @abstractmethod
    def performance(self) -> dict:
        """ latest performance metrics. """
        raise NotImplementedError

    @property
    @abstractmethod
    def pnls(self) -> pd.DataFrame:
        """ historical performane as a dataframe with metrics in columns. """
        raise NotImplementedError
    
    @property
    @abstractmethod
    def current_positions(self) -> dict[Asset,Position]:
        """ current positions (original copy) but without triggering any reconciliation. """
        raise NotImplementedError
    
    @property
    @abstractmethod
    def perfs_history(self) -> pd.DataFrame:
        """ historical performane as a dataframe but without triggering any reconciliation. """
        raise NotImplementedError

    @property
    @abstractmethod
    def current_performance(self) -> dict:
        """ latest performance metrics - but without triggering any reconiliation. """
        raise NotImplementedError

    @property
    @abstractmethod
    def risk_report(self) -> dict:
        """ latest risk metrics in dict format. """
        raise NotImplementedError

    @property
    @abstractmethod
    def transactions(self) -> dict:
        """ a dict for list of orders placed and/or executed for each day. """
        raise NotImplementedError
    
    @property
    @abstractmethod
    def performance_tracker(self) -> Tracker:
        """ the performance tracker object. """
        raise NotImplementedError

    @abstractmethod
    def reset(self, timestamp:pd.Timestamp|None, account:BlotterAccount|float|None=None, 
              initial_positions:dict[Asset, Position]|None=None, **kwargs) -> None:
        """
            Reset the blotter. this resets the transaction tracker as well.

            Args:
                ``timestamp (Timestamp)``: Timestamp of the call
                ``account_net (float)``: To set the account value to.
                ``initial_positions (dict)``: A dict of positions as starting point.

            Returns:
                None.
        """
        raise NotImplementedError

    def save(self, timestamp:pd.Timestamp, *args, **kwargs) -> None:
        """
            Save the blotter. this triggers reconciliation if required.
        """
        if not hasattr(self, '_save'):
            raise NotImplementedError
            
        self._save(timestamp=timestamp, *args, **kwargs) # type: ignore
        for name in self.blotters:
            self.blotters[name].save(
                    timestamp=timestamp, *args, **kwargs)
            
    def read(self, timestamp:pd.Timestamp, *args, **kwargs) -> None:
        """
            Read/ reload the blotter.
        """
        if not hasattr(self, '_read'):
            raise NotImplementedError
            
        self._read(timestamp=timestamp, *args, **kwargs) # type: ignore
        for name in self.blotters:
            self.blotters[name].read(
                    timestamp=timestamp, *args, **kwargs)

    def roll(self, timestamp:pd.Timestamp, *args, **kwargs) -> None:
        """
            Read/ reload the last saved blotter context.
        """
        if not hasattr(self,'_roll'):
            raise NotImplementedError
        
        self._roll(timestamp, *args, **kwargs) # type: ignore
        for name in self.blotters:
            self.blotters[name].roll(timestamp, *args, **kwargs)

    def finalize(self, timestamp:pd.Timestamp|None, *args, **kwargs) -> None:
        """
            Compute at the algo end, and save context.
        """
        # finalize children first
        for name in self.blotters:
            self.blotters[name].finalize(timestamp, *args, **kwargs)
            
        if hasattr(self,'_finalize'):
            self._finalize(timestamp, *args, **kwargs) # type: ignore

    @abstractmethod
    def check_on_restart(self, *args, **kwargs) -> None:
        """
            Do validation, if any, on an algo restart.
        """
        raise NotImplementedError

    @abstractmethod
    def reconcile(self, timestamp:pd.Timestamp|None, *args, **kwargs) -> bool:
        """
            Reconcile algo transactions, positions and accounts with
            broker values. Should act only on this blotter and ignore 
            any children.
        """
        raise NotImplementedError
        
    def reconcile_all(self, timestamp:pd.Timestamp|None, *args, **kwargs) -> bool:
        """
            Reconcile algo transactions, positions and accounts with
            broker values for this blotter and all children.
        """
        status = self.reconcile(timestamp, *args, **kwargs)
        
        for name in self.blotters:
            status &= self.blotters[name].reconcile_all(timestamp, *args, **kwargs)

        return status
        
    def simulate(self, *args, **kwargs) -> None:
        """
            Trigger a simulation of trade fills.
        """
        pass
    
    def set_record_vars(self, record_vars:pd.DataFrame) -> None:
        """
            Update recored variables.
        """
        raise NotImplementedError

    @abstractmethod
    def set_benchmark(self, benchmark:MarketData|None=None) -> None:
        """
            Set up benchmark at the algo start.
        """
        raise NotImplementedError

    @abstractmethod
    def update_benchmark(self, timestamp:pd.Timestamp|None=None, benchmark:MarketData|None=None) -> None:
        """
            Update the benchmark for today. Should be called during
            the algo roll at the end-of-day.
        """
        raise NotImplementedError

    def update_valuation(self, *args, **kwargs) -> bool:
        """
            Update position valuations.
        """
        if not hasattr(self,'_update_valuation'):
            raise NotImplementedError
            
        status = self._update_valuation(*args, **kwargs) # type: ignore
        
        for name in self.blotters:
            status &= self.blotters[name].update_valuation(*args, **kwargs)
        
        return status

    @abstractmethod
    def add_transactions(self, *args, **kwargs) -> None:
        """
            Add a transactions for future reconciliation.
        """
        raise NotImplementedError

    @abstractmethod
    def update_perf_report(self, *args, **kwargs) -> None:
        """
            Compute analytics on the performance.
        """
        raise NotImplementedError

    def _normalize_ts(self, timestamp:pd.Timestamp) -> pd.Timestamp:
        return pd.Timestamp(int(timestamp.value/self._FREQ)*self._FREQ,
                                 tz=timestamp.tz)
        
    @abstractmethod
    def add_blotter(self, *args, **kwargs) -> IBlotter:
        """ add a blotter as a child of this blotter. """
        raise NotImplementedError
        
    def fund_transfer(self, amount:float, *args, **kwargs) -> float:
        """ add funds to virtual account, returns the added amount. """
        if amount<0 and self.account.cash>0 and self.account.cash+amount <0:
            amount = -self.account.cash # cap at max possible withdrawal
            
        self.account.fund_transfer(amount)
        return amount
    
    def remove_blotter(self, name:str) -> IBlotter|None:
        """ remove a child blotter if exists. """
        blotter = self.blotters.pop(name, None)
        
        if blotter:
            try:
                blotter.finalize(self.timestamp)
            except Exception as e:
                if self.logger:
                    msg = f'Failed to finalize blotter for {name}:{str(e)}.'
                    self.logger.error(msg)
            
        return blotter
    
    def get_blotter(self, name) -> IBlotter|None:
        """ get a child blotter by name. """
        return self.blotters.get(name, None)
        
    def sanitize(self, *args, **kwargs) -> None:
        """
            Sanitize blotter data.
        """
        pass
        
    def on_error(self, error:str|Exception) -> None:
        """ 
            A callback invoked when there is an error. This is called before the finalize 
            method if it is a terminating error.
        """
        for name in self.blotters:
            self.blotters[name].on_error(error)
            
        if hasattr(self,'_on_error'):
            self._on_error(error) # type: ignore
    
    def on_cancel(self) -> None:
        """ 
            A callback invoked when the algo or some sub-strategy is cancelled.
        """
        for name in self.blotters:
            self.blotters[name].on_cancel()
            
        if hasattr(self,'_on_cancel'):
            self._on_cancel() # type: ignore
            
    def emit_notify_msg(self, msg:str, 
                        msg_type:Literal['info','error','warning','success','info2']='info') -> None:
        """ Emit a notification msg to the publisher. """
        if self.publisher is None:
            return
        
        try:
            if msg_type != 'info':
                msg = get_clean_err_msg(msg)

            lvl = msg_type if msg_type != 'info2' else 'info'
            packet = create_message_envelope(self.topic, AlgoMessageType.NOTIFY, msg=msg, level=lvl)
            self.publisher.send_to_topic(self.topic, packet)
        except Exception:
            if self.logger:
                msg = f'Failed to send notify message - {msg}.'
                self.logger.error(msg)
    
    def emit_transactions_msg(self, orders:dict[str, Order]) -> None:
        """
            This is called by the specific blotter for emitting the 
            trades packet. This should not process the child blotters.
        """
        if self.publisher is None:
            return

        payload = {}
        rejected = []
        completed = []
        cancelled = []
        
        for order_id in orders:
            o = orders[order_id]
            payload[order_id] = o.to_json()
            if o.is_rejected():
                rejected.append(order_id)
            elif o.is_cancelled():
                cancelled.append(order_id)
            elif o.is_done():
                completed.append(order_id)
                
        if payload:
            packet = create_message_envelope(self.topic, AlgoMessageType.TRADES, data=payload)
            self.publisher.send_to_topic(self.topic, packet)
        
        if rejected:
            rejected = ','.join(rejected)
            msg = f'Order(s) {rejected} were rejected, '
            msg += f'please check the logs and verify your broker account.'
            self.emit_notify_msg(msg, msg_type='error')
        
        if cancelled:
            cancelled = ','.join(cancelled)
            msg = f'Order(s) {cancelled} were cancelled, '
            msg += f'please check the logs and verify your broker account.'
            self.emit_notify_msg(msg, msg_type='warning')
        
        if completed:
            completed = ','.join(completed)
            msg = f'Order(s) {completed} were completed.'
            self.emit_notify_msg(msg)
    
    def emit_valuation_packets(self, timestamp:pd.Timestamp) -> None:
        """
            Recursively emit valuation packets for self and all children.
        """
        if self.publisher is None:
            return
        
        perf = self.get_performance()
        if not perf:
            perf = {}
        
        perf['timestamp'] = str(timestamp)
        packet = create_message_envelope(self.topic, AlgoMessageType.VALUATION, data=perf)
        self.publisher.send_to_topic(self.topic, packet)

    def emit_perf_msg(self, timestamp:pd.Timestamp):
        return self.emit_valuation_packets(timestamp)
    
    def emit_positions_packets(self, timestamp:pd.Timestamp, send:bool=False) -> None:
        """
            emit position packets for self and children.
        """
        if self.publisher is None:
            return
        
        portfolio = {}
        positions = self.get_open_positions()
        for asset in positions:
            portfolio[serialize_asset_symbol(asset)] = positions[asset].to_json()
        
        if portfolio or send:
            portfolio['timestamp'] = str(timestamp)
            packet = create_message_envelope(self.topic, AlgoMessageType.POSITIONS, data= portfolio)
            self.publisher.send_to_topic(self.topic, packet)
    
    def emit_txns_packets(self, timestamp:pd.Timestamp, change:bool) -> None:
        """
            emit transactions packets.
        """
        if self.publisher is None:
            return
        
        last_txns = self.get_transactions()
        if last_txns:
            txns:dict[str,Any] = {"transactions":[txn.to_json() for txn in last_txns]}
            txns['timestamp'] = str(timestamp)
            packet = create_message_envelope(self.topic, AlgoMessageType.TRANSACTIONS, data=txns)
            self.publisher.send_to_topic(self.topic, packet)
            
    def orders_no_reconcile(self) -> dict[str, Order]:
        """ the list of own orders and those from the children, without triggering reconciliation. """
        orders = self._orders_no_reconcile().copy()
        for name in self.blotters:
            orders = {**orders, **self.blotters[name].orders_no_reconcile()}
            
        return orders
            
    def get_orders(self) -> dict[str, Order]:
        """ return own and all children's orders. """
        orders = self.orders.copy()
        for name in self.blotters:
            orders = {**orders, **self.blotters[name].get_orders()}
            
        return orders
    
    def get_open_orders(self) -> dict[str, Order]:
        """ return own and all children's open orders. """
        orders = self.open_orders.copy()
        for name in self.blotters:
            orders = {**orders, **self.blotters[name].get_open_orders()}
            
        return orders
    
    def get_open_positions(self) -> dict[Asset, Position]:
        """ return own and all children's current positions. """
        positions = {k:v.copy() for k,v in self.current_positions.items()}
        for name in self.blotters:
            pos = self.blotters[name].get_open_positions()
            for asset in pos:
                if asset in positions:
                    p = positions[asset].copy()
                    p.add_to_position(pos[asset])
                else:
                    p = pos[asset].copy()
                positions[asset] = p
                
        return positions
    
    def get_transactions(self) -> list[Order]:
        """ return own and all children's transactions. """
        last_txns = []
        if self.transactions:
            t = next(reversed(self.transactions))
            txns_list = self.transactions[t]
            for txn in txns_list:
                last_txns.append(txn)
                
        for name in self.blotters:
            last_txns.extend(self.blotters[name].get_transactions())
            
        return last_txns
    
    def get_round_trips(self) -> list|deque:
        """ return own and all children's combined round trips. """
        round_trips = self.round_trips.copy()
        
        for name in self.blotters:
            round_trips.extend(self.blotters[name].round_trips.copy())
            
        return round_trips
    
    def get_account(self) -> BlotterAccount:
        """ return own and all children's combined account. """
        acct = self.account.copy()
        
        for name in self.blotters:
            acct.add_to_account(self.blotters[name].account)
            
        return acct
    
    def get_performance(self) -> dict:
        """ return own and all children's combined performance. """
        if self.performance_tracker:
            trackers = [self.blotters[name].performance_tracker for name in self.blotters]
            trackers = [t for t in trackers if t is not None]
            return self.performance_tracker.create_current_performance(trackers)
        
        return {}
    
    def get_risk_report(self) -> dict:
        """ return own and all children's combined performance. """
        if self.performance_tracker:
            trackers = [self.blotters[name].performance_tracker for name in self.blotters]
            trackers = [t for t in trackers if t is not None]
            return self.performance_tracker.create_eod_report(self._quick_mode, trackers)
        
        return {}
    
    def get_loss_ratios(self) -> float:
        """ return the combined loss ratio for self and children. """
        perf = self.get_performance()
        if not perf:
            # we are yet to update
            return 1.0
        loss_ratios = perf["net"]/perf["starting_cash"]
        return loss_ratios

_blotter_registry: Dict[str, Type[IBlotter]] = {}
_builtin_blotter_loader: Callable[[Any], None] | None = None

def register_blotter(name, cls: Type[IBlotter]):
    """ register a blotter type to the global mapping. """
    _blotter_registry[name] = cls

def list_blotters() -> list[str]:
    """ get a list of registered blotter names. """
    _ensure_builtins_blotter_loaded()
    return list(_blotter_registry)

def set_builtin_blotter_loader(loader: Callable[[Any], None]):
    """Register a callable that will lazily load built-in IO streamer types."""
    global _builtin_blotter_loader
    _builtin_blotter_loader = loader

def _ensure_builtins_blotter_loaded(blotter_type:str|None=None):
    global _builtins_blotter_loaded
    if _builtin_blotter_loader:
        _builtin_blotter_loader(blotter_type)

    if (blotter_type and blotter_type not in _blotter_registry) or blotter_type is None:
        try:
            load_plugins('blueshift.plugins.blotter')
        except Exception:
            pass

def blotter_factory(blotter_class:str, *args, **kwargs):
    """ factory function to create blotter. """
    from inspect import getfullargspec

    if blotter_class not in _blotter_registry:
        _ensure_builtins_blotter_loaded(blotter_class)  # lazy load builtins
    cls = _blotter_registry.get(blotter_class)

    if not cls:
        raise NotImplementedError(f'Unknown blotter type {blotter_class}.')

    specs = getfullargspec(cls.__init__)

    if specs.varkw:
        kw = kwargs.copy()
    else:
        args_specs = specs.args
        kw = {}
        for key in kwargs:
            if key in args_specs:
                kw[key] = kwargs[key]

    return cls(*args, **kw)

__all__ = [
    'IBlotter',
    'register_blotter',
    'list_blotters',
    'set_builtin_blotter_loader',
    'blotter_factory'
    ]